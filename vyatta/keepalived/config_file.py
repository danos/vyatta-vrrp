#! /usr/bin/python3

# Copyright (c) 2019-2020 AT&T Intellectual Property.
# All rights reserved.
# SPDX-License-Identifier: GPL-2.0-only

import re
import vyatta.abstract_vrrp_classes as AbstractConfig


class KeepalivedConfig(AbstractConfig.ConfigFile):

    def __init__(self, config_file_path="/etc/keepalived/keepalived.conf"):
        self.config_string = """
#
# Autogenerated by /opt/vyatta/sbin/vyatta-vrrp
#


global_defs {
        enable_traps
        enable_dbus
        snmp_socket tcp:localhost:705:1
        enable_snmp_keepalived
        enable_snmp_rfc
}
    """
        self.config_file = config_file_path
        self.implementation_name = "Keepalived"
        self.vrrp_instances = []

        self.VIF_YANG_NAME = "vif"
        self.VRRP_YANG_NAME = "vyatta-vrrp-v1:vrrp"

    def config_file_path(self):
        return self.config_file

    def impl_name(self):
        return self.implementation_name

    def update(self, new_config):
        pass

    def write_config(self):
        pass

    def read_config(self):
        pass

    def convert_to_vci_format(self, config_string):
        pass

    def _get_config_indexes(self, config_lines, search_string):
        config_lines = [x.strip() for x in config_lines]
        config_start_indices = [i for i, x in enumerate(config_lines)
                                if search_string in x]
        return config_start_indices

    def _get_config_blocks(self, config_list, indexes_list):
        config_list = [x.strip() for x in config_list]
        group_list = []
        for idx, start in enumerate(indexes_list):
            if idx+1 < len(indexes_list):
                end = indexes_list[idx+1]
            else:
                end = None
            group_list.append(config_list[start:end])
        return group_list

    def _find_config_value(self, config_list, search_term):
        for line in config_list:
            regex_search = re.match("{}".format(search_term), line)
            if regex_search is not None:
                regex_search = re.match(f"{search_term}\s+(.*)", line)
                if regex_search is not None:
                    return (True, regex_search.group(1))
                else:
                    # Yang JSON representation has single key with no value as
                    # <key>: [null]
                    return (True, [None])
        return (False, "NOTFOUND")

    def _find_interface_in_yang_repr(
            self, interface_name, vif_number, interface_list):

        interface_level = None

        # Interface list is empty so create the interface and add it to the
        # list and then return the reference
        if interface_list == []:
            intf_dict = {"tagnode": interface_name}
            interface_level = intf_dict
            if vif_number != "":
                vif_dict = {"tagnode": vif_number}
                intf_dict[self.VIF_YANG_NAME] = [vif_dict]
                interface_level = vif_dict
            interface_list.append(intf_dict)
        else:
            # Interface list has entries so we need to loop through them and
            # see if the interface already exists
            for intf in interface_list:
                if intf["tagnode"] == interface_name:
                    if vif_number != "":
                        if self.VIF_YANG_NAME not in intf:
                            vif_dict = {"tagnode": vif_number}
                            intf[self.VIF_YANG_NAME] = [vif_dict]
                            interface_level = vif_dict
                            break
                        else:
                            for vif in intf[self.VIF_YANG_NAME]:
                                if vif["tagnode"] == vif_number:
                                    interface_level = vif
                                    break
                            if interface_level is None:
                                vif_dict = {"tagnode": vif_number}
                                intf[self.VIF_YANG_NAME].append(vif_dict)
                                interface_level = vif_dict
                            break
                    else:
                        interface_level = intf
                        break

        # Interface doesn't exists yet but there are interfaces in the list
        # so create the interface and return the reference
        if interface_level is None:
            intf_dict = {"tagnode": interface_name}
            interface_level = intf_dict
            if vif_number != "":
                vif_dict = {"tagnode": vif_number}
                intf_dict[self.VIF_YANG_NAME] = [vif_dict]
                interface_level = vif_dict
            interface_list.append(intf_dict)

        if self.VRRP_YANG_NAME not in interface_level:
            interface_level[self.VRRP_YANG_NAME] = {"start-delay": 0,
                                                    "vrrp-group": []}
        return interface_level


if __name__ == "__main__":
    print("test")
