#!/usr/bin/python3
#
# Module: dbus-notify
#
# **** License ****
#
# Copyright (c) 2019 AT&T Intellectual Property.
# All rights reserved.
#
# Copyright (c) 2016 by Brocade Communications Systems, Inc.
# All rights reserved.
#
# Author: Lorenzo Martinico
# Date: August 2016
# Description: Runs VRRP notify scripts when an interface signals a state change through DBus
#
# SPDX-License-Identifier: GPL-2.0-only
#
# **** End License ****

# 1) Parse command line arguments so we know what vrrp instances we care about.
#    This then allows us to do the next two things...
#
# 2) Send an asynchronous D-Bus request for each vrrp instance given on the cmd-line.
#    We expect a reply containing the current state for the given vrrp instance.
#
# 3) After we receive the reply containing the current state of a given vrrp instance,
#    immediately execute all notify scripts associated with that instance.
#
# 4) Once all asynchrnous requests are finished, subscibe to VrrpStateChange signals.
#
# 5) When we hear about a state transition, the signal emitted should contain vrrp instance
#    info. Parse this to determine if this is an instance we are interested in. If it's not,
#    just discard the message. If it is, call the instance's associated notify scripts along
#    with the new state value.

import argparse
import logging
import os

import daemon
import dbus
from dbus.mainloop.glib import DBusGMainLoop
from gi.repository import GObject as gobject

def state_transition_occurred(*arg, **kwargs):
    # parse the message we've just received and check if it's an instance
    # we're interested in. If it is, call all notify scripts associated with it.
    # Otherwise, just discard the message.
    path = str(kwargs['path'])
    components = path.split("/")
    iface = "vyatta-" + components[5] + "-" + components[6]
    for i in vrrp_instances.keys():
        if i == iface:
            state_update(iface, int(arg[0]))
            return
    return

def state_update(interface, state):
    if int(state) is 1:
        vrrp_instances[interface] = "BACKUP"
    elif int(state) is 2:
        vrrp_instances[interface] = "MASTER"
    elif int(state) is 3:
        vrrp_instances[interface] = "FAULT"
    for script in instance_notify[interface]:
        os.system(script + " INSTANCE " + interface + " " + vrrp_instances[interface])

def get_instance_state_reply_handler(*arg):
    state_update(instance, arg[0][0])

def get_instance_state_error_handler(msg):
    logging.error(msg) 

def vrrp_stopped():
    loop.quit()

## main ##
with daemon.DaemonContext():
    parser = argparse.ArgumentParser(description='VRRP instances we\'re interested in.')
    parser.add_argument('instances', type=str, nargs='+', help='list of vrrp instances')

    args = parser.parse_args()

    vrrp_instances = {} # key=instance_name ; val=state as a string
    instance_notify = {} # key-instance_name ; val=list of scripts

    for instance in args.instances:
        instance_split = instance.split(",")

        interface = instance_split[0]
        group = instance_split[1]

        script_list = []

        if len(instance_split) < 3:
            logging.debug('interface name, group number and at least one script required.')
            continue
        else:
            script_list = instance_split[2:]

        name = "vyatta-" + interface + '-' + group

        vrrp_instances[name] = '' # don't know state yet, hence blank
        instance_notify[name] = script_list


    DBusGMainLoop(set_as_default=True)

    bus  = dbus.SystemBus()

    # subscribe to the signal for all objects implementing the interface
    # http://dbus.freedesktop.org/doc/dbus-python/api/dbus.bus.BusConnection-class.html#add_signal_receiver
    bus.add_signal_receiver(state_transition_occurred, signal_name="VrrpStatusChange",
                     dbus_interface="org.keepalived.Vrrp1.Instance", path_keyword="path")

    # subscribe to the Vrrp quitting signal
    bus.add_signal_receiver(vrrp_stopped, signal_name="VrrpStopped", 
            dbus_interface="org.keepalived.Vrrp1.Vrrp")

    # fetch state for all instances we are interested in
    for instance in vrrp_instances.keys():
        parts = instance.split('-')
        try:
            keepalived_instance = bus.get_object('org.keepalived.Vrrp1',
               '/org/keepalived/Vrrp1/Instance/'+parts[1]+'/'+parts[2], introspect=False)
        except:
            logging.error('keepalived is not running, or it\'s not running it\'s dbus server')
            exit(0)
        try:
            get_property = keepalived_instance.get_dbus_method('Get', 'org.freedesktop.DBus.Properties')
        except:
            logging.error('Failed to get keepalived method')
            exit(0)

        # state will contain either: MASTER | BACKUP | FAULT
        get_property("org.keepalived.Vrrp1.Instance", "State", 
                reply_handler=get_instance_state_reply_handler,
            error_handler=get_instance_state_error_handler)

    loop = gobject.MainLoop()
    loop.run()

    # on loop.quit()
    exit(0)
